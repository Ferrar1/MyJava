## 进程同步与信号量
1. 信号量的引出：在生产者与消费者模式中，counter不能表达是一个生产者还是2个生产者。只发一次信号，无法解决问题：如果根据counter来判断是否发信号，只能发一次信号，即只能唤醒一个生产者。因此还需要一个变量来记录：
   - 图5：
     
     <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/5.PNG" width=75% height=75% />
   - 能记录有多个进程等待
   - 缓冲区满，P1执行，P1然后sleep，记录一个进程等待：sem=-1。（semaphore）
   - P2执行，P2然后sleep，记录2个进程等待:sem=-2
   - C执行一次循环，发现2个进程等待，wakeup一个(从等待队列取):sem=-1.
   - C再执行一次循环，发现1个进程等待，再唤醒一个：sem=0
   - C再执行一次循环：sem=1,即再来一个生产者，不需要睡眠。

2. 案例：一种资源的数量是8，该资源对应信号量的当前值是2，则：可知sem=8,当前值是2说明还有个资源可以使用。

3. 伪代码：
   - 图67：
     
     <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/6.PNG" width=70% height=70% />
     <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/7.PNG" width=70% height=70% />
   - 生产者：生产者在缓冲区满的时候会停，而缓冲区满的时候，此时需要信号量为0.因此需要一个变量empty表示为0的时候缓冲区满。`P(empty)`测试一下是否满，empty即空位。产生内容时即`V(full)`。`P(mutex)`互斥信号量，即锁。
   - 消费者：停的时候即生产的内容为0，这里用full表示为0的时候缓冲区的内容个数,`P(full)`测试一下是否有内容。`V(empty)`即消费一个内容后产生缓冲区的空位。消费完锁这个信号量后还要`V(mutex)`。
4. 信号量的保护
   - 临界区：一次只允许一个进程进入的该进程的那段代码。重点在：找出进程中的共享代码区，图8待解决地方。而读写信号量的代码，一定是临界区。
   
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/8.PNG" width=30% height=30% />
   - 临界区保护基本原则即互斥进入：
     - 有空让进：诺干进程要求进入空闲临界区时，应尽快使一进程进入临界区。
     - 有限等待：从进程发出进入请求，到允许进入，不能无限等待。
   - 轮换法：你进去一次我进去一次。对图8进行的尝试，问题在于不满足有空让进：如果P0完成后想接着再进入，然而P1不在临界区即P1不需要再进入临界区了，导致P0完成后不能接着再进：
   
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/9.PNG" width=50% height=50% />
    - 标记法：留便条的方式。在多进程中依然存在问题：
    
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/10.PNG" width=55% height=55% />
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/11.PNG" width=50% height=50% />
    - Peterson算法：结合标记与轮转思想。
   
