## 操作系统基础
1. 冯若依曼存储程序思想：将程序放到存储器(内存)里，用IP指针或PC指针指向当前处理的指令，取指执行：将该指令载入进控制器，解释执行输出。
    
    
2. 开机计算机：
   - 开机时段寄存器CS=0xFFFF;IP=0x0000,现在CS左移4位+IP得到0xFFFF0。
   - 寻址0xFFFF0,进入ROM BIOS(basic input output system)映射区执行，刚开始只有这一块区有代码。
   - 这段代码，检查RAM，键盘，显示器，软硬磁盘
   - 接着BIOS的这段代码，从磁盘0磁道0扇区读入一个扇区(512字节，该处是引导扇区)，将其放到内存的0x7c00处
   - 接着BIOS的这段代码，设置CS=0x07c0,IP=0x0000(左移4位+IP)，意味着现在开始执行0x07c0处的代码。

3. 引导扇区，是启动设备的第一个扇区。硬盘的第一个扇区存放着开机后执行的第一段我们可以控制的程序。操作系统从这里开始。。。
   - 引导扇区代码bootsect.s是汇编代码。


## 进程与线程
1. CPU的工作原理：取指执行。CPU取寄存器PC值，去相应地址执行程序。   
    >寄存器Register,暂存指令、数据和地址

2. 进程：执行中的程序。记录运行时的状态。
     >引出概念的过程：
     >
     >1. 操作系统要管理CPU，即给一段程序，操作系统去执行，CPU开始工作。
     >2. 如果只执行一段程序，CPU利用率低，因此需要CPU并行执行多个程序，需要在多个程序中切换。
     >3. 切换的时候的程序跟初始静态程序不同，比如不同时刻变量存放的值不一样，因此用PCB（process control block）存放当前运行信息以及PC值。因为有了运行状态，于是引出进程的概念。
3. 多进程
   - 从开机到关机结束的过程如图1：
   
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/1.PNG" width=65% height=65% />

### 用户级线程
1. 进程=资源+指令执行序列。从一个进程切到另一个进程，将资源和指令序列分开，即资源不切。引出线程：
   
   <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/20.PNG" width=65% height=65% />

2. 切换过程中的两个函数
   - yield,核心，就是切换到另一个线程。
   - create就是要制造第一次切换时应该的样子。
3. yield：2个线程执行2个程序时，
   - 对于两个执行序列，公用一个栈，如图2。当执行到B()时，需要将104行的地址压栈，待B函数执行完后出栈继续执行104行程序。当第二个程序遇到yield时继续第一个线程的程序，执行204后**遇到`}`变成汇编指令ret,弹栈**，结果出栈的是404，出现问题。

     <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/2.PNG" width=60% height=60% />
   - 从一个栈到2个栈的转变，如图3。当遇到yield，完成栈的切换，以及。左边是1000这个栈，右边是2000栈，用全局变量TCB数组存储，每个TCB存储当前程序状态。 
     - <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/3.PNG" width=65% height=65% />
     - 现在重点：红色yield里面将TCB2的栈更新一下即404入栈，然后更新当前栈为TCB1的栈，执行完yield后接着ret弹栈就是204，于是切换到204执行。
     - 104是调用B()才入栈，204是调用yield函数入栈，因此在yield返回时ret即弹栈，按理说：yield结束时jmp到204，而没有执行`}` 即不会弹204，因此不需要jmp=204这句话。
4. create：2个线程中需要2个TCB、2个栈，切换的PC程序初始地址在栈中。而ThreadCreate负责从程序做出这三样东西。

### 内核级线程
   - 与用户级线程的区别是，有2套栈：用户栈与内核栈，每个线程对应一套栈。当进程在用户空间运行时，CPU堆栈寄存器的内容是用户堆栈地址，使用用户栈。当进程在内核空间时，CPU堆栈寄存器的内容是内核栈地址空间，使用的是内核栈。
   - [用户栈与内核栈](https://www.jianshu.com/p/6b2ec520ae02)。进程因为中断或系统调用进入内核时(即INT指令执行)，进程使用的堆栈也需要从用户栈到内核栈。进程陷入内核态后，先把用户堆栈SS、SP的地址压到内核堆栈中，然后设置CPU堆栈寄存器为内核栈的地址，这样就完成了用户栈到内核栈的转换。
   - 当进程从内核态恢复到用户态时（即IRet指令执行），把内核中保存的这5个寄存器弹出。这样就实现了内核栈到用户栈的转换。
   - 例子如下图4，read为库函数：
   - 在内核中切换switch_to，以一套栈为单位进行切换：
    
            sys_read(){
				启动磁盘读;
				将自己阻塞;
				找到next; //找到下一个线程
				switch_to(cur,next);//切换下一个线程，cur下一个线程的TCB
			}
  		>TSS 全称task state segment，是指在操作系统进程管理的过程中，任务（进程）切换时的任务现场信息。   
  		>吞吐量：单位时间内成功地传送数据的数量

6. CPU调度
   - FCFS（First Come，First Served），先来先服务
   - SJF，短作业优先。
   - RR，轮转。

7. schedule方法。进入内核就不再叫yield而叫schedule了。counter表示优先级+时间片。

### 进程同步与信号量
1. 信号量的引出：在生产者与消费者模式中，counter不能表达是一个生产者还是2个生产者。只发一次信号，无法解决问题：如果根据counter来判断是否发信号，只能发一次信号，即只能唤醒一个生产者。因此还需要一个变量来记录：
   - 图5：
     
     <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/5.PNG" width=75% height=75% />
   - 能记录有多个进程等待
   - 缓冲区满，P1执行，P1然后sleep，记录一个进程等待：sem=-1。（semaphore）
   - P2执行，P2然后sleep，记录2个进程等待:sem=-2
   - C执行一次循环，发现2个进程等待，wakeup一个(从等待队列取):sem=-1.
   - C再执行一次循环，发现1个进程等待，再唤醒一个：sem=0
   - C再执行一次循环：sem=1,即再来一个生产者，不需要睡眠。

2. 案例：一种资源的数量是8，该资源对应信号量的当前值是2，则：可知sem=8,当前值是2说明还有个资源可以使用。

3. 伪代码：
   - 图67：
     
     <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/6.PNG" width=70% height=70% />
     <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/7.PNG" width=70% height=70% />
   - 生产者：生产者在缓冲区满的时候会停，而缓冲区满的时候，此时需要信号量为0.因此需要一个变量empty表示为0的时候缓冲区满。`P(empty)`测试一下是否满，empty即空位。产生内容时即`V(full)`。`P(mutex)`互斥信号量，即锁。
   - 消费者：停的时候即生产的内容为0，这里用full表示为0的时候缓冲区的内容个数,`P(full)`测试一下是否有内容。`V(empty)`即消费一个内容后产生缓冲区的空位。消费完锁这个信号量后还要`V(mutex)`。
4. 信号量的保护
   - 临界区：一次只允许一个进程进入的该进程的那段代码。重点在：找出进程中的共享代码区，图8待解决地方。而读写信号量的代码，一定是临界区。
   
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/8.PNG" width=30% height=30% />
   - 临界区保护基本原则即互斥进入，另外：
     - 有空让进：诺干进程要求进入空闲临界区时，应尽快使一进程进入临界区。
     - 有限等待：从进程发出进入请求，到允许进入，不能无限等待。
   - 轮换法：你进去一次我进去一次。对图8进行的尝试，问题在于不满足有空让进：如果P0完成后想接着再进入，然而P1不在临界区即P1不需要再进入临界区了，导致P0完成后不能接着再进：
   
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/9.PNG" width=50% height=50% />
    - 标记法：留便条的方式,表示我也想进，是对轮换法的改进。在多进程中依然存在问题：
    
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/10.PNG" width=55% height=55% />
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/11.PNG" width=50% height=50% />
    - Peterson算法：结合标记与轮转思想。135值日，246值日。满足互斥进入：如果2个都进入，`flag[0]=flag[1]=true`,而turn==0==1，符合矛盾。满足有空让进：如果P1不在临界区，则`flag[1]=false`或者turn=0,P0能进。满足有限等待：P1只要跑一次，turn=0，因此P0就不会一直等待。
    
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/12.PNG" width=55% height=55% />
    - 多个进程，不限于2个进程：面包店算法。如何轮转：每个进程都获取一个序号，序号最小的进入。如何标记：进程离开时序号为0，不为0即标记。面包店：号码最小先服务，号码相同，名字靠前先服务。
    - 结合硬件支持： 但多核CPU不适合
   
5. 信号量的实现
   - 生产者及生产者的进程代码：

			Producer(item){
				P(empty);
				...
				V(full);
			}
			//生产者进程，信号量为所有进程共享，存在与内核
			main(){
				sd=sem_open("empty");//打开名字为empty的信号量
				//生产者开始工作
				for(i=1 to 5){
					sem_wait(sd);//判断缓冲区是否有位置写，有的话就写入文件即可。
					write(fd,&i,4);
				}
			}

			//具体打开信号量的方法
			//sem.c文件如下：
			typedef struct{
				char name[20];//这个全局数据里面存有每个信号量的名字
				int value;//对应的值
				task_struct * queue;//对应的队列
			}semtable[20];//定义一个全局数组，存放所有信号量

			//系统调用打开信号量的API
			sys_sem_open(char * name){
				1.在semtable中寻对应的name的信号量；
				2.没有找到就创建一个；
				3.返回对应下标；
			}
			//进程根据信号量判断是否等待的API
			sys_sem_wait(int sd){
				cli();//操作系统通过硬件控制，来进入临界区
				if(semtable[sd].value-- < 0){
					1.设置自己为阻塞；
					2.将自己加入semtable[sd].queue中；
					3.schedule();//即切换到别的进程执行
				}
				sti();//开关中断
			}
	    >唤醒进程的时候，应该通过while的方式将队列中的全唤醒，这样调度的时候优先级高的会先执行。这样还有一个好处：当唤醒的进程进入临界区后信号量改变，while唤醒还没结束，于是后面的进程继续睡眠。

6. 死锁：多个进程由于互相等待对方持有的资源而造成谁都无法执行的情况叫死锁。
   - 成因：
     - 资源互斥
     - 进程占有一些资源，又不释放，再申请别的资源
     - 各自占有的资源与互相申请的资源形成环路等待  
   - 预防：
     - 进程执行前一次性申请所有需要的资源
     - 对资源类型排序，资源申请必须按序进行
   - 避免：判断此次请求是否引起死锁。如果所有进程存在一个可完成的执行序列P1、P2...则称系统处于安全状态。如下图是安全序列，

      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/13.PNG" width=55% height=55% />
      算法实现：找到安全序列的银行家算法。具体执行：首先假装分配，然后调用银行家算法，如果不是安全序列，拒绝请求。如下图所示：
      
      <img src="https://github.com/xuzhuang1996/MyJava/blob/master/img/操作系统/14.PNG" width=70% height=70% />
