## 与框架的区别;
1. 在一个servlet基类中定义了各个service的对象，这样就不用在每个里面单独新建，统一管理。然后各个servlet继承基类的这些service对象直接用。
2. 一对多的时候，从数据库中出一个外键的时候，如果是普通JDBC，需要new的方式生成对象，而DBUtils则是新建处理类，继承BeanListHandler类，在handle里面写解决方案。

## 亮点就是运用反射：
1. admin_Category_list，然后过滤器拦截拿到处理的servlet名Category，以及处理方法list。
2. 重写了基类service方法，在里面根据类名与方法名，反射后调用该方法，完成请求。如果不用反射，那么每一个请求都要新建一个servlet。

## 动态代理：
1. 动态设置目标接口
2. 根据该接口，以get的方式拿到动态生成的代理类
3. 该代理对象调用目标接口方法的时候，该方法被动态重写过了，方法里面通过反射拿到目标接口的方法，invoke进行调用该方法。
4. 如果是在原先基础上进行的扩展，那么就是在代理对象中重写目标接口的时候，进行一个扩展。



## redis集群：有3个主节点，每个主节点都有一个从节点作为备用。节点间交换通过Gossip协议
1. 原理：集群里面的槽总共有16384个，根据节点的个数进行平均分配。分配完后各个节点向其他节点发送数据，这样就知道各个节点负责哪些槽。然后就可以用了。
2. 存取：随机在一个节点执行set操作，该节点使用crc16算法对key计算得哈希值，然后对16384求余，判断余数在哪个节点，然后直接自动跳转到这个对应的节点上进行存取操作。
3. 投票：当一台主节点掉线时，集群中其他的主节点将会通过投票的形式在掉线主结点的从结点中选举一台从节点来代替原先的主节点，并更改剩余从节点slave的主节点为新的主节点。即所有master参与,如果半数以上master节点与master节点通信超时。
4. fail：
   - 如果集群任意master挂掉,且当前master没有slave.集群进入fail状态
   - 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态.
   
## 优惠券
1. 用户获得优惠券的时候，将其信息保存在redis服务器中，设置超时时间。超时将接到失效通知，在Java代码处理。
2. 过程：
   - 用户获取优惠券，保存到数据库。同时保存到redis服务器，设置失效时间。取值：`key-value`->`coupon:ID-目前暂时无需求写值`
   - 过期优惠券的处理。
     - 订阅主题：` subscribe __keyevent@0__:expired`
     - 配置消息监听器：获取失效消息(coupon:ID),从失效消息中分离出优惠券id，查询数据库，修改优惠券状态。
     
## 数据库
一 | 多  
-|-|
Category-分类 | Product-产品 |
Category-分类 | Property-属性 |
Property-属性 | PropertyValue-属性值 |
Product-产品  | PropertyValue-属性值 |
Product-产品  | ProductImage-产品图片 |
User-用户 | Order-订单 |
Product-产品 | OrderItem-订单项 |
User-用户 | OrderItem-订单项 |
Order-订单 | OrderItem-订单项 |
