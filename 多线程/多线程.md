学习地址：https://www.bilibili.com/video/av35364272/?p=4

- [停止线程](#停止线程)
- [创建线程](#创建线程)
- [线程安全](#线程安全)
- [join方法](#join方法)
- [ThreadLocal](#threadLocal)
- [Lock](#lock)
- [AQS](#aqs)
- [读写锁](#读写锁)
- [Condition](#condition)
- [CountDownLatch](#countDownLatch)
- [CyclicBarrier](#cyclicBarrier)
- [Semaphore](#semaphore)
- [Exchanger](#exchanger)




## 停止线程：
1、之前使用的stop方法已不支持，jdk1.6之后interrupt方法。最佳实践：通过bool返回值的 interrupted方法判断是否符合停止条件，调用interrupt方法后，将符合停止条件，于是线程停止：

	Thread thread = new Thread(() -> {
	    while (!Thread.interrupted()) {
		// do more work
	    }
	    // return or throw InterruptedException
	});
	thread.start();

	// 一段时间以后
	thread.interrupt();
	
## 创建线程 
1、如果继承Thread类，就是直接重写了run方法。建议使用Runable创建线程：因为这样使代码逻辑与线程分离,面向接口编程。分析：一个类在实现Runable接口后，使用线程时，是以`Thread thread1 = new Thread(runner1)`方式调用的，其构造函数init方法中有`this.target = target`也就是将runner1传递给thread1的私有成员target，在该thread1开启线程的时候，其run方法如下：   

    public void run() {
        if (target != null) {
            target.run();
        }
    }
2、如果想一个线程执行后有返回值，实现Callable接口。该接口只有一个call方法(类似于run方法)。使用方法：

- 将Xu_thread封装成FutureTask。FutureTask接口实现了RunnableFuture接口，而RunnableFuture接口继承了Runable接口以及Future接口。
- 将FutureTask最终实现了Runable接口，因此可以按照上面创建线程的方式将其包装到Thread类里面，然后就可以启动线程。
- 执行完线程后，拿结果,通过task拿值，线程只负责执行。

		public class demoApplication {
		
		    public static void main(String[] args) throws ExecutionException, InterruptedException {
		        Xu_thread xu = new xu_thread();
		        FutureTask<Integer>futureTask = new FutureTask<>(xu);//第一步
		        Thread myThread = new Thread(futureTask);//第二步
		        myThread.start();
		        System.out.println(futureTask.get());//第三步
		    }
		}
		
		class Xu_thread implements Callable<Integer> {
		    @Override
		    public Integer call() throws Exception {
		        return 1;
		    }
		}

3、创建定时任务。TimerTask是一个抽象类，也实现了Runable接口，因此在run方法中实现定时任务。该方法简单但是不可控。可以考虑quartz框架。

	public class ThreadTest {
	    public static void main(String[] args) {
	        Timer timer = new Timer();
	        timer.schedule(new TimerTask() {
	            @Override
	            public void run() {
	                System.out.println("6");
	            }
	        },0,1000);
	    }
	}

4、线程池。`Executors.newFixedThreadPool(10);`执行100个任务，但是只有10个干活。`Executors.newCachedThreadPool(10)`比较智能，认为够用就开几个，不够再开。

5、spring创建线程。运用注解

6、lambda表达式创建线程。

## 线程安全
1、线程安全出现原因：

- 存在两个或者两个以上的线程对象共享同一个资源；
- 对共享资源进行非原子操作。

2、一些概念

- monitor，是应用于同步问题的人工线程调度工具。Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized范围内，监视器发挥作用。
- **CAS--Compare And Swap** 比较并交换--通过比较传入的旧值和原内存位置中的值比较，来决定是不是要更新数据。CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。
- **Mark Word**是对象头的一部分，对象实例由对象头、实例数据组成。其中`lock record`称之为锁记录的空间，如果上面图中`ptr to lock record`的标志位为01，表示该对象没有锁定，（在竞争CPU处理时）那么虚拟机首先将在当前线程帧栈中建立一个`lock record`的空间，用于存储当前对象的markword的一份拷贝，然后使用CAS操作尝试将mark-word更新为指向`lock record`的指针，如果更新成功那么就说明该线程已经拥有了该对象的使用权限，那么就会将上面`ptr to  lock record`的标志位设置为00证明该对象正在处于轻量级锁定状态。否则进入锁等待。不断获得的过程就是自旋锁。
![image text](https://github.com/xuzhuang1996/MyJava/blob/master/img/Thread/markword.png)
- synchronized关键字加到static静态方法上是给Class类加锁锁，而synchronized关键字加到非static静态方法上是给对象上锁
- 可见性：一个线程修改了这个变量，另一个线程能读到修改后的值。


3、几种锁：https://www.jianshu.com/p/36eedeb3f912

- 偏向锁：很多情况下竞争锁并不是由多个线程，而由一个线程使用。使用场景：只有一个线程在访问同步代码块的场景。偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。

- 轻量级锁：可以同时多个代码块线程去获取锁。
   - 当线程使用该对象的时候，首先要检查该标志位是不是处于轻量级锁定状态，如果是证明有线程正在使用该对象。 
   - 轻量级锁的解锁也是通过CAS来做的，将Lock Record存储的之前markword值，CAS更新回锁对象的MarkWord中，更新成功则整个同步块完成；更新失败，则说明有其他线程尝试过获取该锁，那就要在释放锁的同时唤醒被挂起的线程。
   - 如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。
![image text](https://github.com/xuzhuang1996/MyJava/blob/master/img/Thread/轻量级锁.jpg)

- 重量级锁：内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。
- 自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环

4单例模式

- 饿汉式：直接在类内部new对象，静态方法直接返回单例对象。不存在线程安全问题。

		public Simple(){
		     private static Single s=new Single(); 
	       
		     private Single(){}  
		     public static Simple getSimple(){
		         return s;
		     } 
		}  

- 懒汉式：需要时调用方法，如果为null就new，否则直接返回。存在线程安全问题。

		class Single{
		   private static Single s = null;
		
		   public Single() {
		       if (s == null)
		       　　s = new Single();
		       return s;
		　 }
		}
解决：
   - 如果直接对Single方法加synchronized，每次都要先获得锁再去执行方法体，如果没有锁，就要等待，耗时长。
   - 加同步代码块，减少锁的颗粒大小。因此直接对`s = new Single();`加synchronized。线程A和线程B，线程A读取instance值为null，此时cpu被线程B抢去了，线程B再来判断instance值为null，于是，它开始执行同步代码块中的代码，对instance进行实例化。此时，线程A获得cpu，由于线程A之前已经判断instance值为null，于是开始执行它后面的同步代码块代码。它也会去对instance进行实例化。
   - 双重检查加锁机制。
   - 指令重排序问题。加volatile关键字。因为volatile可以禁止指令重排序。
            
            private static volatile Singleton2 instance;
			public static Singleton2 getInstance(){
			    if(instance == null) {
			        synchronized (Singleton2.class){
			            if (instance == null){
			                instance = new Singleton2();
			            }
			        }
			    }
			    return instance;
			}

5、synchronized锁重入：有一条线程获得了某个对象的锁，此时这个对象还没有释放，当其再次想获得这个对象的锁的时候还是可以获得的。例子：一个线程调用了一个对象的同步方法，在这个方法内部也可以调用**这个对象**的另外一个同步方法。

6、volatile，轻量级锁。保证可见性。volatile变量必须真正独立于其他变量和其以前的值。为何不保证原子性：对于volatile变量a++自增，有3步操作，即读取a的值，执行加操作，写入a。在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；这里的StoreLoad就保证了写入a即Store操作结束后，其他人才能访问a即Load。但是Load到Store这三步，比如2个CPU都执行a++,CPU1读到a初始值10后执行+1，这时还没有写入，还在StoreStore屏障前，而此时CPU2是可以读到a初始值10的，CPU1执行完写，其他线程立刻就发现a=11,但是CPU2已经计算完毕为11，于是再进行写操作为11，这时其他线程想读的时候发现还是11.也就是说没有任何防护措施。

		LoadLoad，保证后面读操作可见
		
		读Load
		
		LoadStore后面写之前，保证前面的读可见
		
		
		执行+1
		
	        StoreStore后面写之前，保证前面的写可见
		
		写Store
		
		StoreLoad保证后面读之前，前面写可见
>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。

>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。

>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。

>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。


7、原子性操作选择AutomicInteger这类类型来实现。源码如下，利用CAS操作。首先get()获取原来值，然后更新它为next，如果预期值不等于当前值，说明其他线程对其进行了修改，继续执行循环。直到自己进行更新操作后的值等于别的线程的值，CAS才返回true。

    //采用自旋的方式，计算新值，然后调用CAS判断是否可以更新,不能更新重新计算
	public final int getAndUpdate(IntUnaryOperator updateFunction) {
	        int prev, next;
	        do {
	            prev = get();
	            next = updateFunction.applyAsInt(prev);
	        } while (!compareAndSet(prev, next));
	        return prev;
	}


## join方法
1、文档：此线程最多等待{@code millis}毫秒。 超时{@code 0}意味着永远等待。

    public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            //Tests if this thread is alive：start，以及no die
            while (isAlive()) {
                //wait是让当前拿到锁的线程放弃锁。一般而言是主线程调用子线程的join方法，也就是这时锁在主线程，主线程进入等待，子线程拿到锁，执行。
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
一段synchronized的代码被一个线程执行之前，他要先拿到执行这段代码的权限，
在Java里边就是拿到某个同步对象的锁（一个对象只有一把锁）；
如果这个时候同步对象的锁被其他线程拿走了，他（这个线程）就只能等了（线程阻塞在锁池等待队列中）。 
取到锁后，他就开始执行同步代码(被synchronized修饰的代码）；
线程执行完同步代码后马上就把锁还给同步对象，其他在锁池中等待的某个线程就可以拿到锁执行同步代码了。

2、应用场景：在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法

	public class TestJoin {
		public static void main(String[] args) throws InterruptedException {
			ThreadTest t1=new ThreadTest("A");
			ThreadTest t2=new ThreadTest("B");
			t1.start();
			t1.join();
			t2.start();
		}
	}
主线程首先执行t1.start();该方法有synchronized关键字，拿到t1对象的锁，接着执行t1.join();通过上面源码可知，进入wait方法，因此主线程放弃了t1对象的锁。此前t1.start后A线程已经启动，因此A线程执行结束后，A线程死亡后会调用自身的notifyAll方法。因此主线程就又起来了。

## ThreadLocal
1、个人理解:例如数据库连接池中的Connection,各个线程之间对Connection变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个Connection进行了修改的。使用的一个例子：下面的类生成每个线程本地的唯一标识符。 线程的id在第一次调用ThreadId.get（）时分配，并在后续调用中保持不变。

	public class ThreadId {
	     // 包含要分配的下一个线程ID的原子整数,
	     private static final AtomicInteger nextId = new AtomicInteger(0);
	
	     // 第一步，声明何种类型的ThreadLocal。第二步，重写初始化方法。Thread local variable containing each thread's ID
	     private static final ThreadLocal<Integer> threadId =
	         new ThreadLocal<Integer>() {
	             @Override protected Integer initialValue() {
	                 return nextId.getAndIncrement();
	         }
	     };
	
	     // 返回当前线程的唯一ID，必要时进行分配
	     public static int get() {
	         return threadId.get();
	     }
	}

2、主要是这几个方法在使用。源码：

- get方法。由于一个线程可能会有多个ThreadLocal这样的变量，因此用map存储所有的ThreadLocal对象以及值。如果threadLocals这个map为空，则新建一个，如果不为空，在这个map中查找当前类型的ThreadLocal变量的值，如果不存在这个类型的ThreadLocal，则设置一个，否则直接返回ThreadLocal对应的值。

	    public T get() {
	        Thread t = Thread.currentThread();
	        ThreadLocalMap map = getMap(t);//getMap就是返回了t.threadLocals这个ThreadLocalMap对象
	        if (map != null) {
	            ThreadLocalMap.Entry e = map.getEntry(this);//根据ThreadLocal对象来获取该对象的map中的元素。
	            if (e != null) {
	                @SuppressWarnings("unchecked")
	                T result = (T)e.value;
	                return result;
	            }
	        }
	        return setInitialValue();
	    }
其中的setInitialValue方法。如果当前线程的threadLocals为空，就创建一个map，里面放当前的ThreadLocal对象，以及初始化的值。如果不为空，则在map里添加新的实体——ThreadLocal对象以及值。

		private T setInitialValue() {
		        T value = initialValue();
		        Thread t = Thread.currentThread();
		        ThreadLocalMap map = getMap(t);
		        if (map != null)
		            map.set(this, value);
		        else
		            createMap(t, value);//以当前ThreadLocal对象，以及初始值value为第一个map中的实体
		        return value;
		}
- set方法。跟get其实差不多，不过为了稳定，都做了初始化的处理。

	    public void set(T value) {
	        Thread t = Thread.currentThread();
	        ThreadLocalMap map = getMap(t);
	        if (map != null)
	            map.set(this, value);
	        else
	            createMap(t, value);
	    }

可能会有内存泄漏问题。




-------------------------------------------
## lock
1、使用Lock可以实现公平性。非阻塞获取锁、能被中断的获取锁、超时获取锁。

2、线程的打扰机制：

- 线程在sleep或wait,join，此时如果别的进程调用此进程的interrupt（）方法，此线程会被唤醒并被要求处理InterruptedException；
- 此线程在运行中，则不会收到提醒。但是此线程的 “打扰标志”会被设置，可以通过isInterrupted()查看并作出处理。

3、Lock的几个方法：

- void lock();用来获取锁。如果锁已被其他线程获取，则进行等待。

		Lock lock = ...;
		lock.lock();
		try{
		    //处理任务
		}catch(Exception ex){
		     
		}finally{
		    lock.unlock();   //释放锁
		}
- boolean tryLock();用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即**immediately**返回。在拿不到锁时不会一直在那等待。
- tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。

		Lock lock = ...;
		if(lock.tryLock()) {
		     try{
		         //处理任务
		     }catch(Exception ex){
		         
		     }finally{
		         lock.unlock();   //释放锁
		     } 
		}else {
		    //如果不能获取锁，则直接做其他事情
		}
- void lockInterruptibly() throws InterruptedException;如果不能立即获取锁，当前线程将变成disable进入等待状态，直到2件事的发生：要么获取锁，要么别的线程中断当前线程。如果当前线程：1）在进入此方法时已经设置了该线程的中断状态；2）在等待获取锁的同时被中断。 则抛出 InterruptedException，并且清除当前线程的已中断状态。 注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。

		public void method() throws InterruptedException {
		    lock.lockInterruptibly();
		    try {  
		     //.....
		    }
		    finally {
		        lock.unlock();
		    }  
		}

##aqs（AbstractQueuedSynchronizer）
1、主要用以自定义同步器。维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。假设state=0表示同步状态可用（如果用于锁，则表示锁可用），state=1表示同步状态已被占用（锁被占用）。AQS定义两种资源共享方式：Exclusive（独占，排他，只有一个线程能执行，如ReentrantLock，Reentrant本身意思是重入）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。

2、自定义同步器实现时实现对应方法

- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

3、文档中：

- **AQS其子类应定义为非公共内部帮助程序类，用于实现其封闭类的同步属性**。实践：ReentrantLock作为同步锁需要实现lock接口，而lock接口的具体实现，则由ReentrantLock中的继承AQS的辅助类FairSync等进行实现。
- **此类旨在成为依赖单个原子int值来表示状态的大多数同步器的有用基础**。实践：状态值state的获取设置getState()、setState(int)、compareAndSetState(int, int)。
   - compareAndSetState：当并发情况下多个线程都读取到 state == 0时，例如：多个线程调用同一个方法，在该方法中加锁mylock.lock(),这个mylock锁的状态只有一个，是共享的，因此必须保证其原子性，需要使用CAS操作保证其原子性，以免一个线程在设置状态时有其他线程对其也进行了操作。
   - setState：如果是重入锁的情况，才能使用setState(int)这个方法，因为同一个线程对象使用锁，不会有线程安全问题。

4、ReentrantLock源码分析：（https://www.bilibili.com/video/av35365988/?p=3）  
ReentrantLock实现的lock()如下：

    public void lock() {
        sync.lock();
    }
其中sync是ReentrantLock的静态内部类`abstract static class Sync extends AbstractQueuedSynchronizer`的对象，其lock方法是抽象方法。**将具体实现交给子类**，而Sync有NonfairSync、FairSync两个同属于ReentrantLock的静态内部类：

- FairSync中加锁过程：对Sync的lock进行重写，acquire是AQS的函数，继承后FairSync直接使用。

        final void lock() {
            acquire(1);
        }
下面是AQS对acquire的实现，如果tryAcquire拿到了锁，就直接结束;如果没有拿到锁，执行acquireQueued加入队列进行等待：

	    public final void acquire(int arg) {
	        if (!tryAcquire(arg) &&
	            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
	            selfInterrupt();
	    }
   - 由于想要实现自己的同步器，需要重写AQS的tryAcquire方法去尝试获取锁。FairSync中对tryAcquire进行重写：

	        //Don't grant access unless recursive call or no waiters or is first
			protected final boolean tryAcquire(int acquires) {
			            final Thread current = Thread.currentThread();
			            int c = getState();//获取锁的状态
			            if (c == 0) {
	                        //等于0说明还没有别的线程占有锁，担心多个不同线程进入该方法操作，需要CAS从0开始操作，等于预期值acquires后返回true
			                if (!hasQueuedPredecessors() &&
			                    compareAndSetState(0, acquires)) {
	                            //设置拥有独占访问权限的线程为当前这个线程。
			                    setExclusiveOwnerThread(current);
			                    return true;
			                }
			            }
                        //不等于0说明有别的线程占用了锁。判断占有锁的线程是否为当前这个线程，
                        //如果是，就不会被锁在外面，则实现了锁重入，并重新设置状态值；如果不是，则返回false，
			            else if (current == getExclusiveOwnerThread()) {
                            //在独占锁中，加锁的时候状态会增加1（当然可以自己修改这个值），在解锁的时候减掉1
			                int nextc = c + acquires;
			                if (nextc < 0)
			                    throw new Error("Maximum lock count exceeded");
			                setState(nextc);
			                return true;
			            }
			            return false;
			}
   - 如果`tryAcquire()`返回false，进入`acquireQueued()`方法。

			final boolean acquireQueued(final Node node, int arg) {
			        boolean failed = true;
			        try {
			            boolean interrupted = false;
			            for (;;) {
			                final Node p = node.predecessor();
	                        //如果当前节点node的上一个结点为head,（还不知道head有没有释放锁）
	                        //如果能够获取锁，说明说明head已经出队列了，将node设为head（维护队列）。
			                if (p == head && tryAcquire(arg)) {
			                    setHead(node);
			                    p.next = null; // help GC
			                    failed = false;
			                    return interrupted;
			                }
                            //如果还是拿不到锁。进入等待。
			                if (shouldParkAfterFailedAcquire(p, node) &&
			                    parkAndCheckInterrupt())
			                    interrupted = true;
			            }
			        } finally {
			            if (failed)
			                cancelAcquire(node);
			        }
			}
   - acquireQueued的第一个参数`addWaiter(Node.EXCLUSIVE)`将当前线程加入到等待队列的队尾，并返回当前线程所在的结点，tail尾结点是AQS最主要的三个成员变量之一

			private Node addWaiter(Node mode) {
			        Node node = new Node(Thread.currentThread(), mode);
			        // Try the fast path of enq; backup to full enq on failure
			        Node pred = tail;
			        if (pred != null) {
			            node.prev = pred;
	                    //expect预期原值为当前尾节点pred，update将tail的值更新为当前node。
			            if (compareAndSetTail(pred, node)) {
			                pred.next = node;
			                return node;
			            }
			        }
	                //如果尾节点为空，enq方法进入队列。
			        enq(node);
			        return node;
			}
   - acquireQueued中的`shouldParkAfterFailedAcquire(p, node)`检查更新未能获取锁的节点的状态，然后维护队列。`parkAndCheckInterrupt()`将当前线程挂起到WATING状态，在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()

			private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
			        int ws = pred.waitStatus;
			        if (ws == Node.SIGNAL)
			            /* Node.SIGNAL释放锁的时候pred的后续的节点需要被唤醒
			             * This node has already set status （asking后面的修饰status）asking a release
			             * to signal it, so it can safely park.
			             */
			            return true;
			        if (ws > 0) {
			            /* 大于0说明是取消状态，小于0是等待状态
			             * Predecessor was cancelled. Skip over predecessors and
			             * indicate retry.
			             */
			            do {
			                node.prev = pred = pred.prev;//这里相当于删除了中间取消状态的节点
			            } while (pred.waitStatus > 0);
			            pred.next = node;//找到一个节点为等待状态，将节点的next指向参数node
			        } else {
			            /* 如果等待状态不为Node.SIGNAL，那么将其设置为Node.SIGNAL
			             * waitStatus must be 0 or PROPAGATE.  Indicate that we
			             * need a signal, but don't park yet.  Caller will need to
			             * retry to make sure it cannot acquire before parking.
			             */
			            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
			        }
			        return false;
			}

- FairSync中解锁过程：ReentrantLock实现的unlock()调用Sync的release方法：

		public final boolean release(int arg) {
		        if (tryRelease(arg)) {
		            Node h = head;
		            if (h != null && h.waitStatus != 0)
		                unparkSuccessor(h);
		            return true;
		        }
		        return false;
		}
   - 自定义同步锁，需要重写AQS的`tryRelease()`方法去释放锁。FairSync直接继承了Sync的tryRelease()方法。
		
			 protected final boolean tryRelease(int releases) {
	                    //同一个锁，在可以重入后，可能会被叠加为2、3、4这些值，只有unlock()的次数与lock()的次数对应才会将Owner线程设置为空，而且也只有这种情况下才会返回true。
			            int c = getState() - releases;
			            if (Thread.currentThread() != getExclusiveOwnerThread())
			                throw new IllegalMonitorStateException();
			            boolean free = false;
	                    //将状态减掉传入的参数值（参数是1），如果结果状态为0，就将独占锁的Owner设置为null，以使得其它的线程有机会进行执行
			            if (c == 0) {
			                free = true;
			                setExclusiveOwnerThread(null);
			            }
			            setState(c);
			            return free;
			 }
   - `unparkSuccessor(h)`方法唤醒等待队列中下一个线程。维护队列。
   
			   private void unparkSuccessor(Node node) {
			        /*
			         * If status is negative (i.e., possibly needing signal) try
			         * to clear in anticipation of signalling.  It is OK if this
			         * fails or if status is changed by waiting thread.
			         */
			        int ws = node.waitStatus;
			        if (ws < 0)
			            compareAndSetWaitStatus(node, ws, 0);
			
			        /*
			         * Thread to unpark is held in successor, which is normally
			         * just the next node.  But if cancelled or apparently null,
			         * traverse backwards from tail to find the actual
			         * non-cancelled successor.
			         */
			        Node s = node.next;//这里node就是传入的head节点
			        if (s == null || s.waitStatus > 0) {
			            s = null;
			            for (Node t = tail; t != null && t != node; t = t.prev)
			                if (t.waitStatus <= 0)
			                    s = t;
			        }
			        if (s != null)//如果s不为空，说明队列中还有其他节点，于是释放s这个节点被挂起的线程
			            LockSupport.unpark(s.thread);
			    }

5、公平锁与非公平锁：针对锁的获取而言

- 公平锁：锁的获取顺序应该符合请求的绝对时间顺序
- 非公平锁：上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。   
在ReentrantLock源码中，公平与非公平的区别仅仅是公平锁的tryAcquire方法多了一个hasQueuedPredecessors()，查询队列中当前线程前面是否还有别的等待线程。非公平锁因为没有这个方法判断，因此就算自己在队列末尾，直接通过CAS占有锁。

	    public final boolean hasQueuedPredecessors() {
	        // The correctness of this depends on head being initialized
	        // before tail and on head.next being accurate if the current
	        // thread is first in queue.
	        Node t = tail; // Read fields in reverse initialization order
	        Node h = head;
	        Node s;
	        return h != t &&
	            ((s = h.next) == null || s.thread != Thread.currentThread());
	    }

## 读写锁
1、属于排他锁、共享锁：写操作排他，读操作允许多个线程读取。

2、AQS文档中：

- 子类必须定义更改此状态的受保护方法，并**根据**要获取或释放的此**对象定义该状态的含义**，读写锁需要保持的状态：
   - 写锁重入的次数
   - 读锁的个数
   - 每个读锁重入的次数  
有2种锁，如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，state是int值为32位，前16位表示读，后16位表示写。
 
	        static final int SHARED_SHIFT   = 16;                     //这里<<将数转为二进制后左移
	        static final int SHARED_UNIT    = (1 << SHARED_SHIFT);    //0000 0000 0000 0001 0000 0000 0000 0000
	        static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;//0000 0000 0000 0000 1111 1111 1111 1111
	        static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;//0000 0000 0000 0000 1111 1111 1111 1111
	        //这里>>>无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充
	        /** Returns the number of shared holds represented in count  */
	        static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }//将c转为二进制后右移16位（删低位）拿到高位
	        /** Returns the number of exclusive holds represented in count  */
	        static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }//拿到低位（可以把c的高位全变为0）

3、ReentrantReadWriteLock有2把锁，本身只是实现ReadWriteLock接口。使用readLock()时返回ReadLock内部类。ReadLock实现了Lock接口，而Lock接口中的方法的具体实现又是通过继承AQS的Sync静态内部类。

4、ReentrantReadWriteLock源码分析：

- ReadLock中对lock()方法的重写：

	    public void lock() {
	        sync.acquireShared(1);//读操作调用共享锁
	    }
AQS的子类Sync作为辅助类，实现对tryAcquireShared方法重写：

	       protected final int tryAcquireShared(int unused) {
	            /*
	             * Walkthrough:
	             * 1. If write lock held by another thread, fail.
	             * 2. Otherwise, this thread is eligible for
	             *    lock wrt state, so ask if it should block
	             *    because of queue policy. If not, try
	             *    to grant by CASing state and updating count.
	             *    Note that step does not check for reentrant
	             *    acquires, which is postponed to full version
	             *    to avoid having to check hold count in
	             *    the more typical non-reentrant case.
	             * 3. If step 2 fails either because thread
	             *    apparently not eligible or CAS fails or count
	             *    saturated, chain to version with full retry loop.
	             */
	            Thread current = Thread.currentThread();
	            int c = getState();
                //exclusiveCount(c)拿到低位，如果不等于0说明还有写操作，而且如果是其他线程在进行写操作，return -1；
	            if (exclusiveCount(c) != 0 &&
	                getExclusiveOwnerThread() != current)
	                return -1;
                //拿到高位，就是读操作的所有线程的所有进入次数
	            int r = sharedCount(c);
                //由于并发，在CAS之前会有很多线程试图改状态c，这个时候所有线程取出的c都是一样的，而只有成功修改c的线程才算进入。
	            if (!readerShouldBlock() &&
	                r < MAX_COUNT &&
	                compareAndSetState(c, c + SHARED_UNIT)) {
                    //r=0说明第一次进入
	                if (r == 0) {
	                    firstReader = current;//为了一个效率问题，firstReader是不会放入到readHolds中的，如果读锁仅有一个的情况下就会避免查找readHolds。
	                    firstReaderHoldCount = 1;
	                } else if (firstReader == current) {
	                    firstReaderHoldCount++;//如果r不等于0而且当前线程等于firstReader说明第一次的线程重入。
	                } else {
                        //现在就是有第一次之外的线程进入了.首先变量介绍：
                        //HoldCounter记录一个线程重入的次数，算是个计数器、
                        //cachedHoldCounter代表最后一个获取读锁的线程的计数器，缓存起来用于后面的操作
                        //readHolds当前注意是当前线程持有的可重入读锁的数量，在没有进行set的情况下get到的均是initialValue方法里面new的HolderCounter对象，如果重入的时候，get就是当前线程的那个HolderCounter对象了。

	                    HoldCounter rh = cachedHoldCounter;
	                    if (rh == null || rh.tid != getThreadId(current))
                            //如果cachedHoldCounter为空，只能是第二个的线程新进来时cachedHoldCounter为空，给第二个线程new计数器，并更新cachedHoldCounter。
                            //如果cachedHoldCounter不为空，且不是当前线程的计数器。这个判断才是处理重入的情况。解释：
                            //当第三个及以后线程新进来，new计数器；假设进的顺序是12342，那么readHolds.get的就是2号线程的计数器。这就在重入；假设顺序1222，不需要更新cachedHoldCounter，所以不需要进这个判断。
	                        cachedHoldCounter = rh = readHolds.get();

                        //如果cachedHoldCounter不为空，且为当前线程，且cachedHoldCounter的count为0
                        //我觉得：当一个线程作为cachedHoldCounter释放了锁count为0，readHolds将remove计数器。
                        //Removed whenever a thread's read hold count drops to 0.
	                    else if (rh.count == 0)
	                        readHolds.set(rh);
	                    rh.count++;
	                }
	                return 1;
	            }
                //第一次获取读锁失败，有两种情况：
                //1）没有写锁被占用时，尝试通过一次CAS去获取锁时，更新失败（说明有其他读锁在申请）
                //2）当前线程占有写锁，并且有其他写锁在当前线程的下一个节点等待获取写锁，除非当前线程的下一个节点被取消，否则fullTryAcquireShared也获取不到读锁.
	            return fullTryAcquireShared(current);
	        }
扩展：这里其实就出现了**锁降级**。锁降级:写锁降级成为读锁。如果其他线程占写锁，拿锁失败；如果当前线程占写锁，将写锁降级，还可以获取读锁。  
**意义**：读锁的获取的目的是 “为了保证数据的可见性”。如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程获取了写锁并修改了数据，那么当前线程无法感知数据更新。   
实例：

		public void processData() {
		        r.lock();
		        if (!update) {
		            r.unlock();//在写操作前需要释放读锁
		            w.lock();
		            try {
		                if (!update) {
		                    //数据准备
		                    update = true;
		                }
                        //写锁释放前加一个读锁：如果直接释放写锁，这时所有等待写锁的线程都来竞争这个写锁。
		                r.lock();
		            } finally {
		                w.unlock();
		            }
		            //完成锁降级，写锁降级为读锁
		            try {
		                //数据逻辑处理
		            } finally {
		                r.unlock();
		            }
		        }
		}

- WriteLock中对lock()方法的重写

        public void lock() {
            sync.acquire(1);//写操作调用排他锁
        }
AQS的子类Sync作为辅助类，实现对tryAcquire方法重写：

         protected final boolean tryAcquire(int acquires) {
            /*
             * Walkthrough:
             * 1. If read count nonzero or write count nonzero
             *    and owner is a different thread, fail.
             * 2. If count would saturate, fail. (This can only
             *    happen if count is already nonzero.)
             * 3. Otherwise, this thread is eligible for lock if
             *    it is either a reentrant acquire or
             *    queue policy allows it. If so, update state
             *    and set owner.
             */
            Thread current = Thread.currentThread();
            int c = getState();//拿到状态
            int w = exclusiveCount(c);//根据状态，拿到低位的值
            //c不等于0，不是第一次进来。其他锁第一个判断就false了，考虑重入拿锁的情况。
            if (c != 0) {
                // (Note: if c != 0 and w == 0 then shared count != 0)
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                if (w + exclusiveCount(acquires) > MAX_COUNT)//这里是32位分16、16位。如果超过16位了，肯定不能保存了。
                    throw new Error("Maximum lock count exceeded");
                // Reentrant acquire
                setState(c + acquires);//重入成功时，同一个写线程，无读线程，高位为0，可以直接相加。
                return true;
            }
            //如果是第一次进来
            //如果是非公平锁writerShouldBlock()，一直返回false(writer总是可以闯入);那么就执行CAS，如果CAS也成功return true
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }

## condition
1、前面Lock接口其实还有一个方法没有讲，`Condition newCondition();`,返回一个Condition实例，这个实例与该lock绑定在一起。这个lock必须被当前线程持有，才能进入等待状态，对Condition＃await()的调用将在等待之前以原子方式释放锁，并在等待返回之前重新获取锁。对于signal的调用。如果任何线程正在条件等待，当一个线程signal进行唤醒。 然后该线程必须在从await返回之前重新获取锁。

2、ConditionObject类是AQS的内部类，实现了Condition接口。**使用场景**：经典问题，三个线程依次打印ABC。详细见https://www.cnblogs.com/shijiaqi1066/p/3412346.html

3、同步队列，在AQS中维护的队列，没有拿到锁就拿到同步队列中，而等待队列，调用await方法后加入等待队列。

3、ConditionObject类源码分析https://www.jianshu.com/p/52089c4eefdd，从await方法开始：

	public final void await() throws InterruptedException {
	            if (Thread.interrupted())
	                throw new InterruptedException();
	            Node node = addConditionWaiter();//封装node后添加队尾
	            int savedState = fullyRelease(node);//既然是等待，需要释放所有锁。
	            int interruptMode = 0;
                //现在这个节点一直在等待队列中，因此将其挂起park。
                //这里 Node 从等待队列转移到同步队列有两种可能(1其他线程调用signal进行转移(2当前线程被中断而进行Node的转移(就在checkInterruptWhileWaiting里面进行转移）
	            while (!isOnSyncQueue(node)) {
	                LockSupport.park(this);//挂起，如果唤醒就执行下面的判断
	                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
	                    break;//说明此是通过线程中断的方式进行唤醒, 并且已经进行了node的转移, 转移到Sync Queue里面
	            }
                
	            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
	                interruptMode = REINTERRUPT;
                //通过 "node.nextWaiter != null" 说明现在在等待队列也有。
                //因为通过中断唤醒的话, 此刻代表线程的 Node 在 Condition Queue 与 Sync Queue 里面都会存在
	            if (node.nextWaiter != null) // clean up if cancelled
	                unlinkCancelledWaiters();
	            if (interruptMode != 0)//代表通过中断的方式唤醒线程
	                reportInterruptAfterWait(interruptMode);
	}
   - 上面的addConditionWaiter();主要是将线程封装成一个Node放到Condition Queue里面。由于队列里面的有效状态只能是CONDITION，因此当加入新节点时先判断最后一个节点不是有效节点，对整个队列进行一次清理。（增加与清理在一起，赞）

			private Node addConditionWaiter() {
			            Node t = lastWaiter;
			            // If lastWaiter is cancelled, clean out.
			            if (t != null && t.waitStatus != Node.CONDITION) {
			                unlinkCancelledWaiters();//如果最后元素无效，队列里面进行清理，并重新拿到最后元素
			                t = lastWaiter;
			            }
			            Node node = new Node(Thread.currentThread(), Node.CONDITION);
			            if (t == null)
			                firstWaiter = node;//说明队列为空了，
			            else
			                t.nextWaiter = node;//否则，添加到队列末尾
			            lastWaiter = node;//前面2种情况都有首，需要重新设置尾。
			            return node;
			}
   - unlinkCancelledWaiters()对队列进行清理，我觉得这种算法用来清理标记元素，应该很常见（这种是需要保存首尾的元素。）

		private void unlinkCancelledWaiters() {
		            Node t = firstWaiter;
		            Node trail = null;//引入该变量，作为清理时遇到的最后一个有效的节点
		            while (t != null) {
		                Node next = t.nextWaiter;//保存当前节点t的next节点，用于下次循环的处理，
                        //如果t节点不是有效，需要删除
		                if (t.waitStatus != Node.CONDITION) {
                            //将t与原先队列进行了断开处理。算作删除。现在的队列以next开头,但是firstWaiter的值还没有更新.
		                    t.nextWaiter = null;
                            //说明目前还没有有效节点，firstWaiter先临时设置为next，等待下次循环处理next。
		                    if (trail == null)
                                //firstWaiter的值应该是一个有效节点，如果下次循环发现next没问题，那么firstWaiter就不用再更新，否则继续这样。
		                        firstWaiter = next;
		                    else
		                        trail.nextWaiter = next;//trail存在，则构造了一个新的队列，下次从next开始处理。
		                    if (next == null)//如果next为空，则说明处理结束。
		                        lastWaiter = trail;
		                }
		                else
		                    trail = t;//如果t节点是有效的，与目前更新到的t是有效节点，保留到trail
		                t = next;//现在开始进入下一次循环，处理next。
		            }
		}

## countDownLatch
1、文档：一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。

2、文档实例1，启动信号，在driver为继续执行worker做好准备之前，它会阻止所有的worker继续执行。完成信号，它允许driver在完成所有worker之前一直等待。

	 class Driver { // ...
	   void main() throws InterruptedException {
	     CountDownLatch startSignal = new CountDownLatch(1);
	     CountDownLatch doneSignal = new CountDownLatch(N);
	
	     for (int i = 0; i < N; ++i) // create and start threads
	       new Thread(new Worker(startSignal, doneSignal)).start();
	
	     doSomethingElse();            // don't let run yet
	     startSignal.countDown();      // let all threads proceed因为startSignal的初始值为1.countDown后为0。
	     doSomethingElse();
	     doneSignal.await();           // wait for all to finish。当前线程一直等待直到doneSignal为0
	   }
	 }
	
	 class Worker implements Runnable {
	   private final CountDownLatch startSignal;
	   private final CountDownLatch doneSignal;
	   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
	      this.startSignal = startSignal;
	      this.doneSignal = doneSignal;
	   }
	   public void run() {
	      try {
	        startSignal.await();//当前线程一直等待直到startSignal的计数器为0,除非线程中断。
	        doWork();
	        doneSignal.countDown();//现在结束信号减1.
	      } catch (InterruptedException ex) {} // return;
	   }
	
	   void doWork() { ... }
	 }
另一种典型用法是，将一个问题分成 N 个部分，用执行每个部分并让锁存器倒计数的 Runnable 来描述每个部分，然后将所有 Runnable 加入到 Executor 队列。当所有的子部分完成后，协调线程就能够通过await。详细见文档：http://tool.oschina.net/apidocs/apidoc?api=jdk-zh

3、总结后的使用场景：

- 实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。
- 开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。


## cyclicBarrier
1、文档：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用（类似开会时必须等人到齐后才能继续每个人发言）。因为该 barrier 在释放等待线程后可以重用，所以称它为循环的 barrier。

2、CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用。文档实例：

	 class Solver {
	   final int N;
	   final float[][] data;
	   final CyclicBarrier barrier;
	   
		   class Worker implements Runnable {
		     int myRow;
		     Worker(int row) { myRow = row; }
		     public void run() {
		       while (!done()) {
                 //这个处理函数，可以在await之前执行，用以等待所有线程执行结束后再执行可选的Runnable命令。
                 //如果在await之后执行，用以模拟并发
		         processRow(myRow);
		         try {
                   //每次调用await方法都会使计数器-1，当减少到0时就会唤醒所有的线程, await() 都将返回能到达屏障处的线程的索引
		           barrier.await();
		         } catch (InterruptedException ex) { 
		             return; 
		         } catch (BrokenBarrierException ex) { 
		             return; 
		         }
		       }
		     }//end of Worker
	   }
	
	   public Solver(float[][] matrix) {
	     data = matrix;
	     N = matrix.length;
	     barrier = new CyclicBarrier(N, 
	                                 new Runnable() {
	                                   public void run() { 
	                                     mergeRows(...); 
	                                   }
	                                 });
	     for (int i = 0; i < N; ++i) 
	       new Thread(new Worker(i)).start();
	
	     waitUntilDone();
	   }
	 }
在这个例子中，每个 worker 线程处理矩阵的一行，在处理完所有的行之前，该线程将一直在屏障处等待。处理完所有的行之后，将执行所提供的 Runnable 屏障操作，并合并这些行。如果合并者确定已经找到了一个解决方案，那么 done() 将返回 true，所有的 worker 线程都将终止。

## semaphore
1、文档：通常用于限制可以访问某些资源（物理或逻辑的）的线程数目。不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。调用 acquire() 时无法保持同步锁，因为这会阻止将项返回到池中

2、文档例子：

	class Pool {
	   private static final int MAX_AVAILABLE = 100;
	   private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);
	
	   public Object getItem() throws InterruptedException {
         //该方法从semaphore获取许可, 一直阻塞直到获取许可或者中断
	     available.acquire();
	     return getNextAvailableItem();//不用管怎么实现，就是拿池中东西的操作
	   }
	
	   public void putItem(Object x) {
	     if (markAsUnused(x))
           //释放许可，并将其返还给semaphore
	       available.release();
	   }
	
	   // Not a particularly efficient data structure; just for demo
	
	   protected Object[] items = ... whatever kinds of items being managed
	   protected boolean[] used = new boolean[MAX_AVAILABLE];
	
	   protected synchronized Object getNextAvailableItem() {
	     for (int i = 0; i < MAX_AVAILABLE; ++i) {
	       if (!used[i]) {
	          used[i] = true;
	          return items[i];
	       }
	     }
	     return null; // not reached
	   }
	
	   protected synchronized boolean markAsUnused(Object item) {
	     for (int i = 0; i < MAX_AVAILABLE; ++i) {
	       if (item == items[i]) {
	          if (used[i]) {
	            used[i] = false;
	            return true;
	          } else
	            return false;
	       }
	     }
	     return false;
	   }
	
	 }
从池拿东西的时候getItem，每个线程必须从信号量获取许可，从而保证可以使用该项。该线程结束后，将项返回到池中并将许可返回到该信号量，从而允许其他线程获取该项。


## exchanger
1、一般用于两个工作线程之间交换数据。

2、文档案例：

	class FillAndEmpty {
	   Exchanger<DataBuffer> exchanger = new Exchanger<DataBuffer>();
	   DataBuffer initialEmptyBuffer = ... a made-up type
	   DataBuffer initialFullBuffer = ...
	
	   class FillingLoop implements Runnable {
	     public void run() {
	       DataBuffer currentBuffer = initialEmptyBuffer;
	       try {
	         while (currentBuffer != null) {
	           addToBuffer(currentBuffer);
	           if (currentBuffer.isFull())
                 //exchange方法：等待另一个线程到达当前交换点（除非线程中断）然后交换彼此的对象。因此有2种交换时出现的情况
                 //如果还没有其他线程在交换点等待，就进入等待直到有线程交换或者中断。
	             currentBuffer = exchanger.exchange(currentBuffer);//这就是一个交换点
	         }
	       } catch (InterruptedException ex) { ... handle ... }
	     }
	    }//end of FillingLoop
	
	   class EmptyingLoop implements Runnable {
	     public void run() {
	       DataBuffer currentBuffer = initialFullBuffer;
	       try {
	         while (currentBuffer != null) {
	           takeFromBuffer(currentBuffer);
	           if (currentBuffer.isEmpty())
	             currentBuffer = exchanger.exchange(currentBuffer);
	         }
	       } catch (InterruptedException ex) { ... handle ...}
	     }
	    }
	
	   void start() {
	     new Thread(new FillingLoop()).start();
	     new Thread(new EmptyingLoop()).start();
	   }
	  }
该类使用 Exchanger 在线程间交换缓冲区，因此，在需要时，填充缓冲区的线程获取一个新腾空的缓冲区，并将填满的缓冲区传递给腾空缓冲区的线程。




## ConcurrentHashMap和BlockingQueue需要自己找
## 线程池http://www.importnew.com/19011.html#comment-721759

